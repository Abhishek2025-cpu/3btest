const mongoose = require('mongoose');
const QRCode = require('qrcode');
const MainItem = require('../models/item.model'); // IMPORTANT: Use the new MainItem model
const Employee = require('../models/Employee');
const { uploadBufferToGCS } = require('../utils/gcloud');

// ADVANCED CREATE FUNCTION
exports.createItemWithBoxes = async (req, res) => {
  try {
    const { 
      itemNo, 
      length, 
      noOfSticks, 
      helperEid, 
      operatorEid, 
      shift, 
      company,
      noOfBoxes // The new field for number of boxes
    } = req.body;

    // --- 1. Initial Validations ---
    if (!req.file) {
      return res.status(400).json({ error: 'Product image is required' });
    }
    const numBoxes = parseInt(noOfBoxes, 10);
    if (isNaN(numBoxes) || numBoxes <= 0) {
        return res.status(400).json({ error: 'A valid, positive number of boxes is required.' });
    }
    
    // Check if an item with this itemNo already exists
    const existingItem = await MainItem.findOne({ itemNo });
    if (existingItem) {
        return res.status(409).json({ error: `An item with itemNo '${itemNo}' already exists.` });
    }

    // --- 2. Fetch Shared Data ---
    const [helper, operator, productImageUpload] = await Promise.all([
        Employee.findOne({ eid: helperEid }),
        Employee.findOne({ eid: operatorEid }),
        uploadBufferToGCS(req.file.buffer, req.file.originalname, 'product-images', req.file.mimetype)
    ]);

    if (!helper || !operator) {
      return res.status(400).json({ error: 'Invalid helper or operator EID' });
    }
    
    // --- 3. Generate Box Data in Parallel ---
    // We create an array of numbers from 1 to numBoxes to map over
    const boxIndexes = Array.from({ length: numBoxes }, (_, i) => i + 1);

    const generatedBoxes = await Promise.all(
      boxIndexes.map(async (index) => {
        // A. Generate padded serial number (this is the "autogenerated mode")
        // .padStart() is a great string method for this. '3' means the total length will be 3.
        const boxSerialNo = String(index).padStart(3, '0'); // Results in '001', '002', ..., '010', etc.

        // B. Create rich, self-contained data for the QR code
        const qrCodeData = JSON.stringify({
            itemNo: itemNo,
            boxSerialNo: boxSerialNo,
            totalBoxes: numBoxes,
            length: length,
            noOfSticks: noOfSticks,
            operator: operator.name,
            helper: helper.name,
            shift: shift,
            company: company,
            createdAt: new Date().toISOString()
        });
        
        // C. Generate QR code image buffer
        const qrCodeBuffer = await QRCode.toBuffer(qrCodeData, {
            type: 'png',
            errorCorrectionLevel: 'H',
            margin: 1,
            width: 500,
        });

        // D. Upload the unique QR code for this box to GCS
        const qrCodeFileName = `qr-${itemNo}-${boxSerialNo}.png`;
        const qrCodeUpload = await uploadBufferToGCS(qrCodeBuffer, qrCodeFileName, 'qr-codes', 'image/png');

        // E. Return the final sub-document object for this box
        return {
          boxSerialNo: boxSerialNo,
          qrCodeUrl: qrCodeUpload.url,
          // stockStatus will use its default value 'In Stock'
        };
      })
    );

    // --- 4. Create the MainItem document with all its boxes ---
    const newMainItem = await MainItem.create({
      itemNo,
      length,
      noOfSticks,
      helper: { _id: helper._id, name: helper.name, eid: helper.eid },
      operator: { _id: operator._id, name: operator.name, eid: operator.eid },
      shift,
      company,
      productImageUrl: productImageUpload.url,
      boxes: generatedBoxes // Assign the array of generated boxes
    });

    res.status(201).json(newMainItem);
  } catch (error) {
    console.error('Create Item with Boxes Error:', error.message, error.stack);
    res.status(500).json({ error: error.message || 'Failed to create item and its boxes' });
  }
};



exports.updateItemWithBoxes = async (req, res) => {
  try {
    const { 
      itemNo,
      length,
      noOfSticks,
      helperEid,
      operatorEid,
      shift,
      company,
      noOfBoxes // can be changed
    } = req.body;

    // 1️⃣ Find existing item
    const existingItem = await MainItem.findOne({ itemNo });
    if (!existingItem) {
      return res.status(404).json({ error: `Item with itemNo '${itemNo}' not found.` });
    }

    // 2️⃣ Fetch employees (optional update)
    const [helper, operator] = await Promise.all([
      helperEid ? Employee.findOne({ eid: helperEid }) : null,
      operatorEid ? Employee.findOne({ eid: operatorEid }) : null,
    ]);

    if (helperEid && !helper) {
      return res.status(400).json({ error: 'Invalid helper EID.' });
    }
    if (operatorEid && !operator) {
      return res.status(400).json({ error: 'Invalid operator EID.' });
    }

    // 3️⃣ Update product image if provided
    let updatedProductImageUrl = existingItem.productImageUrl;
    if (req.file) {
      const productImageUpload = await uploadBufferToGCS(
        req.file.buffer,
        req.file.originalname,
        'product-images',
        req.file.mimetype
      );
      updatedProductImageUrl = productImageUpload.url;
    }

    // 4️⃣ Determine new number of boxes
    const newBoxCount = noOfBoxes ? parseInt(noOfBoxes, 10) : existingItem.boxes.length;
    if (isNaN(newBoxCount) || newBoxCount <= 0) {
      return res.status(400).json({ error: 'Invalid number of boxes.' });
    }

    let updatedBoxes = existingItem.boxes;

    // 5️⃣ If number of boxes changed, regenerate boxes & QR codes
    if (newBoxCount !== existingItem.boxes.length) {
      const boxIndexes = Array.from({ length: newBoxCount }, (_, i) => i + 1);

      updatedBoxes = await Promise.all(
        boxIndexes.map(async (index) => {
          const boxSerialNo = String(index).padStart(3, '0');
          const qrCodeData = JSON.stringify({
            itemNo: itemNo,
            boxSerialNo,
            totalBoxes: newBoxCount,
            length: length || existingItem.length,
            noOfSticks: noOfSticks || existingItem.noOfSticks,
            operator: (operator?.name || existingItem.operator.name),
            helper: (helper?.name || existingItem.helper.name),
            shift: shift || existingItem.shift,
            company: company || existingItem.company,
            updatedAt: new Date().toISOString()
          });

          const qrCodeBuffer = await QRCode.toBuffer(qrCodeData, {
            type: 'png',
            errorCorrectionLevel: 'H',
            margin: 1,
            width: 500,
          });

          const qrCodeFileName = `qr-${itemNo}-${boxSerialNo}.png`;
          const qrCodeUpload = await uploadBufferToGCS(qrCodeBuffer, qrCodeFileName, 'qr-codes', 'image/png');

          return {
            boxSerialNo,
            qrCodeUrl: qrCodeUpload.url,
            stockStatus: 'In Stock',
          };
        })
      );
    }

    // 6️⃣ Update item details
    existingItem.length = length ?? existingItem.length;
    existingItem.noOfSticks = noOfSticks ?? existingItem.noOfSticks;
    existingItem.shift = shift ?? existingItem.shift;
    existingItem.company = company ?? existingItem.company;
    existingItem.productImageUrl = updatedProductImageUrl;
    if (helper) existingItem.helper = { _id: helper._id, name: helper.name, eid: helper.eid };
    if (operator) existingItem.operator = { _id: operator._id, name: operator.name, eid: operator.eid };
    existingItem.boxes = updatedBoxes;

    // 7️⃣ Save and respond
    await existingItem.save();

    res.status(200).json({
      message: 'Item updated successfully.',
      updatedItem: existingItem,
    });
  } catch (error) {
    console.error('Update Item Error:', error.message, error.stack);
    res.status(500).json({ error: error.message || 'Failed to update item.' });
  }
};






exports.addBoxesToItem = async (req, res) => {
  // MODIFICATION 1: We are getting 'id' from the URL, not 'itemNo'.
  const { id } = req.params; 
  const { numberOfNewBoxes } = req.body;

  try {
    // --- 1. Validation ---
    // ADDED: A crucial check to ensure the ID is a valid MongoDB ObjectId format before querying.
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'Invalid item ID format.' });
    }

    const numBoxesToAdd = parseInt(numberOfNewBoxes, 10);
    if (isNaN(numBoxesToAdd) || numBoxesToAdd <= 0) {
      return res.status(400).json({ error: 'A valid, positive number of new boxes is required.' });
    }

    // --- 2. Find the Existing Item ---
    // MODIFICATION 2: Use findById() which is faster and designed for this purpose.
    const existingItem = await MainItem.findById(id); 
    if (!existingItem) {
      // MODIFICATION 3: The error message now correctly refers to the ID.
      return res.status(404).json({ error: `Item with ID '${id}' not found.` });
    }

    // --- 3. Determine Starting Point and New Total ---
    // (This logic is correct and remains unchanged)
    const lastBoxCount = existingItem.boxes.length;
    const newTotalBoxes = lastBoxCount + numBoxesToAdd;

    // --- 4. Generate New Box Data in Parallel ---
    // (This logic is correct and remains unchanged)
    const newBoxIndexes = Array.from({ length: numBoxesToAdd }, (_, i) => i + 1);

    const generatedNewBoxes = await Promise.all(
      newBoxIndexes.map(async (index) => {
        const newSerialNumber = lastBoxCount + index;
        const boxSerialNo = String(newSerialNumber).padStart(3, '0');

        const qrCodeData = JSON.stringify({
          itemNo: existingItem.itemNo,
          boxSerialNo: boxSerialNo,
          totalBoxes: newTotalBoxes,
          length: existingItem.length,
          noOfSticks: existingItem.noOfSticks,
          operator: existingItem.operator.name,
          helper: existingItem.helper.name,
          shift: existingItem.shift,
          company: existingItem.company,
          createdAt: new Date().toISOString()
        });

        const qrCodeBuffer = await QRCode.toBuffer(qrCodeData, {
          type: 'png', errorCorrectionLevel: 'H', margin: 1, width: 500,
        });

        const qrCodeFileName = `qr-${existingItem.itemNo}-${boxSerialNo}.png`;
        const qrCodeUpload = await uploadBufferToGCS(qrCodeBuffer, qrCodeFileName, 'qr-codes', 'image/png');

        return {
          _id: new mongoose.Types.ObjectId(),
          boxSerialNo: boxSerialNo,
          qrCodeUrl: qrCodeUpload.url,
          stockStatus: 'In Stock',
          createdAt: new Date(),
          updatedAt: new Date()
        };
      })
    );
    
    // --- 5. Update the MainItem with the new boxes ---
    // (This logic is correct and remains unchanged)
    await MainItem.updateOne(
      { _id: existingItem._id },
      { $push: { boxes: { $each: generatedNewBoxes } } }
    );

    // --- 6. Fetch and return the fully updated document ---
    // (This logic is correct and remains unchanged)
    const updatedItem = await MainItem.findById(existingItem._id);

    res.status(200).json({
      message: `${numBoxesToAdd} boxes added successfully.`,
      data: updatedItem
    });

  } catch (error) {
    console.error('Add Boxes to Item Error:', error.message, error.stack);
    res.status(500).json({ error: error.message || 'Failed to add boxes to the item' });
  }
};







exports.getAllItemsForList = async (req, res) => {
  try {
    const items = await MainItem.aggregate([
      {
        $sort: { createdAt: -1 } // Sort newest first
      },
      {
        $addFields: {
          // Create a new field 'boxCount' with the size of the 'boxes' array
          boxCount: { $size: "$boxes" }
        }
      },
      {
        $project: {
          boxes: 0 // Now, explicitly remove the large 'boxes' array from the output
        }
      }
    ]);
    res.status(200).json(items);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch items' });
  }
};

// CORRECTED CODE (includes the 'boxes' array)
exports.getAllItems = async (req, res) => {
  try {
    // Fetch all items and include their full details, including the 'boxes' array.
    // The sort({ createdAt: -1 }) will show the newest items first.
    const items = await MainItem.find().sort({ createdAt: -1 });
    res.status(200).json(items);
  } catch (error) {
    console.error("Failed to fetch items:", error);
    res.status(500).json({ error: 'Failed to fetch items' });
  }
};

// You might want a new function to get a single item with its boxes
exports.getItemByItemNo = async (req, res) => {
  try {
    const item = await MainItem.findOne({ itemNo: req.params.itemNo });
    if (!item) {
        return res.status(404).json({ error: 'Item not found' });
    }
    res.status(200).json(item);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch item' });
  }
};




exports.deleteItem = async (req, res) => {
  try {
    const item = await MainItem.findByIdAndDelete(req.params.id);
    if (!item) return res.status(404).json({ error: 'Item not found' });
    res.status(200).json({ message: 'Item deleted successfully' });
  } catch (error) {
    console.error('Delete item error:', error);
    res.status(500).json({ error: 'Failed to delete item' });
  }
};


exports.updateStockStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    if (!['In Stock', 'Out of Stock'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status value' });
    }

    const item = await Item.findByIdAndUpdate(id, { status }, { new: true });
    if (!item) return res.status(404).json({ error: 'Item not found' });

    res.json(item);
  } catch (err) {
    console.error('Update stock status error:', err);
    res.status(500).json({ error: 'Server error' });
  }
};

