const mongoose = require('mongoose');
const QRCode = require('qrcode');
const MainItem = require('../models/item.model'); // IMPORTANT: Use the new MainItem model
const Employee = require('../models/Employee');
const { uploadBufferToGCS } = require('../utils/gcloud');

// ADVANCED CREATE FUNCTION
exports.createItemWithBoxes = async (req, res) => {
  try {
    const { 
      itemNo, 
      length, 
      noOfSticks, 
      helperEid, 
      operatorEid, 
      shift, 
      company,
      noOfBoxes // The new field for number of boxes
    } = req.body;

    // --- 1. Initial Validations ---
    if (!req.file) {
      return res.status(400).json({ error: 'Product image is required' });
    }
    const numBoxes = parseInt(noOfBoxes, 10);
    if (isNaN(numBoxes) || numBoxes <= 0) {
        return res.status(400).json({ error: 'A valid, positive number of boxes is required.' });
    }
    
    // Check if an item with this itemNo already exists
    const existingItem = await MainItem.findOne({ itemNo });
    if (existingItem) {
        return res.status(409).json({ error: `An item with itemNo '${itemNo}' already exists.` });
    }

    // --- 2. Fetch Shared Data ---
    const [helper, operator, productImageUpload] = await Promise.all([
        Employee.findOne({ eid: helperEid }),
        Employee.findOne({ eid: operatorEid }),
        uploadBufferToGCS(req.file.buffer, req.file.originalname, 'product-images', req.file.mimetype)
    ]);

    if (!helper || !operator) {
      return res.status(400).json({ error: 'Invalid helper or operator EID' });
    }
    
    // --- 3. Generate Box Data in Parallel ---
    // We create an array of numbers from 1 to numBoxes to map over
    const boxIndexes = Array.from({ length: numBoxes }, (_, i) => i + 1);

    const generatedBoxes = await Promise.all(
      boxIndexes.map(async (index) => {
        // A. Generate padded serial number (this is the "autogenerated mode")
        // .padStart() is a great string method for this. '3' means the total length will be 3.
        const boxSerialNo = String(index).padStart(3, '0'); // Results in '001', '002', ..., '010', etc.

        // B. Create rich, self-contained data for the QR code
        const qrCodeData = JSON.stringify({
            itemNo: itemNo,
            boxSerialNo: boxSerialNo,
            totalBoxes: numBoxes,
            length: length,
            noOfSticks: noOfSticks,
            operator: operator.name,
            helper: helper.name,
            shift: shift,
            company: company,
            createdAt: new Date().toISOString()
        });
        
        // C. Generate QR code image buffer
        const qrCodeBuffer = await QRCode.toBuffer(qrCodeData, {
            type: 'png',
            errorCorrectionLevel: 'H',
            margin: 1,
            width: 500,
        });

        // D. Upload the unique QR code for this box to GCS
        const qrCodeFileName = `qr-${itemNo}-${boxSerialNo}.png`;
        const qrCodeUpload = await uploadBufferToGCS(qrCodeBuffer, qrCodeFileName, 'qr-codes', 'image/png');

        // E. Return the final sub-document object for this box
        return {
          boxSerialNo: boxSerialNo,
          qrCodeUrl: qrCodeUpload.url,
          // stockStatus will use its default value 'In Stock'
        };
      })
    );

    // --- 4. Create the MainItem document with all its boxes ---
    const newMainItem = await MainItem.create({
      itemNo,
      length,
      noOfSticks,
      helper: { _id: helper._id, name: helper.name, eid: helper.eid },
      operator: { _id: operator._id, name: operator.name, eid: operator.eid },
      shift,
      company,
      productImageUrl: productImageUpload.url,
      boxes: generatedBoxes // Assign the array of generated boxes
    });

    res.status(201).json(newMainItem);
  } catch (error) {
    console.error('Create Item with Boxes Error:', error.message, error.stack);
    res.status(500).json({ error: error.message || 'Failed to create item and its boxes' });
  }
};


// You might want a new function to get a single item with its boxes
exports.getItemByItemNo = async (req, res) => {
  try {
    const item = await MainItem.findOne({ itemNo: req.params.itemNo });
    if (!item) {
        return res.status(404).json({ error: 'Item not found' });
    }
    res.status(200).json(item);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch item' });
  }
};


exports.getAllItems = async (req, res) => {
  try {
    // We can exclude the large 'boxes' array from the list view for performance
    const items = await MainItem.find().select('-boxes');
    res.status(200).json(items);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch items' });
  }
};

exports.deleteItem = async (req, res) => {
  try {
    const item = await Item.findByIdAndDelete(req.params.id);
    if (!item) return res.status(404).json({ error: 'Item not found' });
    res.status(200).json({ message: 'Item deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete item' });
  }
};

exports.updateStockStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    if (!['In Stock', 'Out of Stock'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status value' });
    }

    const item = await Item.findByIdAndUpdate(id, { status }, { new: true });
    if (!item) return res.status(404).json({ error: 'Item not found' });

    res.json(item);
  } catch (err) {
    console.error('Update stock status error:', err);
    res.status(500).json({ error: 'Server error' });
  }
};

